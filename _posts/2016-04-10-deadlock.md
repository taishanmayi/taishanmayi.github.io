---
layout: post_layout
title: 死锁及其避免
categories: [linux c]
---  

### 1. 什么是死锁   
&ensp; 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。  

### 2. 形成死锁的条件   
&ensp; 形成死锁有四个必要的条件：  
&ensp; 1. 互斥条件：多个进程同时需要获得同一资源，而该资源同一时刻只能由一个进程占有，不能被共享。  
&ensp; 2. 请求与保持条件：已经得到资源的进程可以再次申请新的资源。  
&ensp; 3. 非剥夺(抢占)条件：已经分配的资源不能从相应的进程中被强制地剥夺。   
&ensp; 4. 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）。  

### 3. 死锁的避免   
&ensp; 要避免死锁，只需要让上述的四个必要的条件不能同时满足即可，然而实际情况中，刻意去避免某一个条件是难以实现的。  
在参与竞争的进程比较少时，使用破坏循环等待条件的方法来避免死锁是一个比较有实用价值的方法。假设有三种锁L1，L2，L3，只需要规定必须按照一定的顺序获尝试获取锁，如按照L1-->L2-->L3的顺序，，就可以避免出现死锁的情况。但是这种方式有一定的弊端：  

+ 限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销；  
+ 为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。  
